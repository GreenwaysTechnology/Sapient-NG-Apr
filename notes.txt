
Type script :

scales javascript?

Scaling means expanding features of javascript.

Object based Pardigms

  Object oriented concepts
      Typing : Static typing / Strong typing

static typing

int a =10;

a ="hello";

var i =90;

i ="hello"
/////////////////////////////////////////////////////////////////////////////////////////////////////////

Type system

1.primitive
 number,string,booleans

2.Reference types / complex types/ object types

Employee,Customer.


Customer -- must have a  Order only.


class  Customer{
 
  private Order order;
    Customer(Order order){
          this.order = order
   }
 
}

new Customer(new Order())
new Customer(new Product());

/////////////////////////////////////////////////////////////////////////////////////////////////////

What if javascript has two things


1.Strong typing

2.Object Oriented Programming principles

You can use java script in enteriprise computing


TS is project created by ms to add the above features on js.


IS TS Separate pl.

 No!.

TS is just remake of javascript with strong typing  , oop.

//////////////////////////////////////////////////////////////////////////////////////////////////////

TS =  ES 6 + ES 5 + Additional features


Does TS has runtime?

No!

TS is only for source code , not for exection,.

Every TS programm finally becomes javascript.


Source code (ts) -------------------compilation---------------->Javascript---run on host.(browser/node)


TS application:

Project setup :

1.node js
2.vs code
3.create project with package.json
4.install type script compiler


project config :  tsconfig.json
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TS : TYPE system:

object oriented Programming

ts compiler by default compiles ts code into ES 5 .
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

OO :

1.classes
   -instance variables,methods,contructors
object creations
   constructor parameters

ts :
2.interfaces
3.abstract classes
4.encapsulation


////////////////////////////////////////////////////////////////////////////////////

state initzation :

1.hard coded
2.after object creation
3.constructor parameters


encapsulation:

What is encasulation ?

 To protect code sharing.

ts offers three ways you can protect code.

code could be class,instance variable,method,constructor....

private :
  instance vaiables, instance methods
public
   instance vaiables, instance methods
protected
  instance vaiables, instance methods

private : class bounday,
public : across the classes
protected ; within two classes , but it should be in hiertance

Note: by default all code is public .

keywords, private



/////////////////////////////////////////////////////////////////////////////////////

code refactoring:

with encapsulation modifier , we can reduce  lot of declaration code.

how to declare instance variable, initalize them

1.inside class
2.inside constructor

class Customer {
    //instance variables : 
    private id: number
    private name: string;
    private isActive: boolean;
    constructor(id: number = 1, name: string = 'defaultName', isActive?: boolean) {
        this.id = id;
        this.name = name;
        this.isActive = isActive;
    }
}

local variables: variables inside function/constructor ,or arg
constructor(id: number = 1, name: string = 'defaultName', isActive?: boolean) {
       
    }
the id,name are local variables

 "ts offers feature , local variables can be converted into instance variables by adding encp modiferes(private/public) "

//////////////////////////////////////////////////////////////////////////////////////////////////////

Hierachy: has-a, is-a


HAS-A : dependency injection

IS:A
//inheritance:
/**
 * Base class could be
 * 1.concrete class
 * 2.interfaces
 * 3.abstract class
 */
//
class Account {
    constructor(public accNo?: number) {
        console.log('Account class')
    }
    deposit(): number {
        return 10;
    }
}
class SavingsAccount extends Account {
    constructor(id: number) {
        super(id);
        console.log('Savings account!')
    }
    //method redefinging (overriding)
    deposit(): number {
        return 100 * super.deposit();
    }
}
let sb = new SavingsAccount(12);
console.log(sb.accNo)
console.log(sb.deposit())
////////////////////////////////////////////////////////////////////////////////////
//interfaces : generic inheritance
interface Runnable {
    //just method declaration
    run(): void
}
class Lion implements Runnable {
    //you must provide implementation
    run(): void {
        console.log('Lion runs!')
    }
}
class Wheel implements Runnable {
    run(): void {
        console.log('Wheel runs!')
    }
}
let lion = new Lion()
let wheel = new Wheel();

lion.run()
wheel.run();
////////////////////////////////////////
//Abstract classes: similar to interfaces but which is having common behaviour
//for same family of child classes.
//abstract classes = genric  + common implemenation

abstract class Animal {
    abstract eat(): void;
    //concret
    saveAnimals(): string {
        return 'Save Animals from Hunters!'
    }
}
class Tiger extends Animal {
    eat() {
        console.log('Tiger eats')
    }
}
let tiger = new Tiger();
tiger.eat();
console.log(tiger.saveAnimals());

class Elephant extends Animal {
    eat() {
        console.log('Elephant eats')
    }
}
let ele = new Elephant();
ele.eat();
console.log(ele.saveAnimals());

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Reference types : object types
/**
 * 1.class can act as type of object : 
 * 2.interface can act as type of object
 * 3.type keyword can be used for object types
 *  * 
 */

//primitive
let a: number = 1

//class as type 
// class Customer {
//     id: number;
//     name: string;
// }
//interface as type
// interface Customer {
//     id: number;
//     name: string;
// }
//type keyword
type Customer = {
    id: number;
    name: string;
    city?: string;
}
//literal objects
let customer: Customer = {
    id: 1,
    name: 'Subramanian',
}
///////////

class Employee {
    constructor(public id: number = 2, public name: string = 'default') { }
}


// let emp: Employee = new Employee();
// emp.id = 10;
// emp.name = 'Subramanian';
// emp.salary = 900;

//Type inference
// let emp = new Employee();
// emp.id = 10;
// emp.name = 'Subramanian';
// emp.salary = 900;

type EmployeeType = {
    id: number;
    name: string;
    salary: number;
}

let emp = new Employee() as EmployeeType;
emp.id = 10;
emp.name = 'Subramanian';
emp.salary = 900;


let emp1 = new Employee() as any;
emp1.id = 10;
emp1.name = 'Subramanian';
emp1.salary = 900;

Arrays Types,Generics

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Decorators:
 meta  Programming

Annoations in other languages.
..........................................................


@Entity  
class Employee{
   
}

ES 7 spec added decorators(annotation) in javascript

Types of decorator

1.on class :
  class level decorator
2.method 
   method level decorator
3.on variable
   field level decorator.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Code :

1.decorator code

 decorator is just js function
@ symbol to bind decorator


2.application code which uses decorators

//Decorators

//decorator code
/**
 * 1.function must take arg: target (on which the decorator has been attached)
 */

//Level 1: declaration
// function Course(target: any) {
//     console.log('Course decorator is used!')
// }
//Level 2 : add decorator logic
//Get the Student Prototype Object, add courseName property, and set the value
// function Course(target: any) {
//     //Logic
//     Object.defineProperty(target.prototype, "courseName", {
//         value: 'Angular with Type script'
//     });
// }

// //app code
// @Course
// class Student {
//     constructor(public firstName?: string, public lastName?: string) { }
// }
// let student = new Student("Subramanian", "Murugan") as any;
// console.log(`${student.firstName} ${student.lastName} is learning ${student.courseName}`);

//use case 2 : course information as input


// function Course(target: any) {
//     //Logic
//     Object.defineProperty(target.prototype, "courseName", {
//         value: 'Angular with Type script'
//     });
// }

//Level 3 : add decorator logic,with input
type CourseType = {
    code: string;
    courseName: string;
}

function Course(courseinfo: any) {
    //target should be inside another function
    return function (target: any) {
        //Logic
        Object.defineProperty(target.prototype, 'courseinfo', { value: courseinfo })
    }

}

function Logger(config: any) {
    return function (target: any) {
        console.log("\x1b[44m%s\x1b[0m", `${config.type} - ${config.message} on ${new Date()}`);
    }
}

//method decorator
function extendAble(value: any) {
    return function (target: any, prop: any, propdescriptor: PropertyDescriptor) {
        console.log(target);
        console.log(prop);
        console.log(propdescriptor);
        propdescriptor.writable = value;
    }
}

//field decorator
function Input(label: string) {
    return function (target: any, key: string) {
        console.log(target)
        console.log(key);
        Object.defineProperty(target, key, {
            configurable: false,
            get: () => label
        });
    }
}



@Course({ name: 'Node js' })
@Logger({
    message: 'Have latest Version',
    type: 'Warning'
})
class Student {

    @Input('Sapient Learning Division')
    instituteName: string;

    constructor(public firstName?: string, public lastName?: string) { }
    //cost of this is fixed
    @extendAble(false)
    calculateCost() {
        return 10000;
    }
}
let student = new Student("Subramanian", "Murugan") as any;
console.log(` ${student.instituteName} ${student.firstName} ${student.lastName} is learning ${student.courseinfo.name}`);

student.calculateCost = function () {
    return 15000;
}

console.log(`Course cost ${student.calculateCost()}`);

////////////////////////////////////////////////////////////////////////////////////////////////////////

Modularity :

Break application into  separate files and folders.

Sharing code across the files.

Modularity in js:

1.namespace
2.amd
3.cjs
4.es6 modules
5.system
6.UMD

DEV:

1.CJS - node  -  exports,module.exports,require
2.ES6 - amd + cjs => export,export default , import

Angular uses es 6 modules for code sharing.

TS module System:

1.es 6 module
2.namepaces

Angular module system:

1.es 6 modules =>
2.Angular modules



ES 6 modules:

1.export ,export default : sharing code

2.import : linking files and getting shared code



////////////////////////////////////////////////////////////////////////////////////////////////

import {Component} from '@angular/core'
          |
        class Name ----------------export class Component{} - component.ts

import { CustomerService } from './services/CustomerService';
          |
          class Name --------->export class CustomerService ----CustomerService.ts
            

src
  |
  services
     |
      CustomerService
      OrderService
      .....

if you want to import many services /class in single file

 ReportComponent.ts
    
 import { CustomerService } from './services/CustomerService';
 import { OrderService } from './services/OrderService';

in barrel export mode

import { CustomerService ,OrderService } from './services';


How to implement?

 src
  |
  services
     |
      CustomerService
      OrderService
      index.ts -
	reexport
export { CustomerService } from './CustomerService';

 main.ts


Sync 

Async 

/////////////////////////////////////////////////////////////////////////////////////////////////

Generics:

Type erasor
////////////////////////////////////////////////////////////////////////////////////////////////////////

Angular:

platform :
    -Core Runtime
    ->Core libs
Framework
     -collection of projects to build an end to end 


MVC - Design pattern for build user interface

dependency injection:
   
  -Object has-a relationship
     ->IOC : Inversion of Control :https://martinfowler.com/articles/injection.html

Java : spring : the reference implementation of ioc pattern.

Angular 2 , adopated ioc design pattern at core.


HAS - A Problmes

1.dev need to create objects
2.dev need to bind objects : wiring

How to solve it: 
  IOC

invert : do opposit
of control : managment

Here , dev has control to create objects, link those objects => we need to invert this
  
  - Automation :  Object creations, linking objects
      -Automation software : injector
   
NG : will create objects, wire those objects  automatatically through "Angular $injector Service"

////////////////////////////////////////////////////////////////////////////////////////////////////


Architecture
1.Framework architecture

Angular framework is collection of many projects.

 google/searchEngine,map,mail,........
  |                 
 companyName  - Projects
 

Angular is also starts angular root

   @angular/ core /animations /cli /common
     |           |
  namepace       projects
   
   @angular/core   
   @angular/cli
   @angular/common
   etc...


////////////////////////////////////////////////////////////////////////////////////////////////////
1.Application architecture

 Ng collection of Objects

Objects
 1.infra objects
 2.domain objects - biz objects like customers,orders....



Starting Coding:
...............

Angular Project : cli

Angular CLI    Automate && accelerate your work flow

From the Project creation, to dev,testing,deployment

>Get the cli project
npm install -g @angular/cli
ng new my-dream-app
cd my-dream-app
ng serve
//////////////////////////////////////////////////////////////////////////////////////////////////////


Automation by webpack<--angular.json is app config
.............................................................................................

Angular application is kept inside src/app folder:


Application : 
collection many things

 -html file
 -css file
 -ts file
    |
    component
    service
    directive
    ..
    module file
    unit test

Application is collection of objects.

1.Component :

 Component is object
 Component is Controller Object in MVC
 Component is Face to the End User which represents User Interface

View :
  It is run time representation of template.

template :
  It is design time /compile time represention of view.

Template :
  Collection of html elements and angular instructions.
/////////////////////////////////////////////////////////////////////////////////////////////////

Every Component two things

1.template
    ->HTML + Angular instructions
    -Styling: css

Component relationship objects
  ->Module
  ->Service
  ->Directive
  ->Pipe
/////////////////////////////////////////////////////////////////////////////////////////////////////

NG collection of many objects

 ->Module Object
     Which talks about modularity : 
          ES 6 modularity
                code sharing and file linking

          angular modularity
               sharing objects and linking objects 
            

Angular has two module object:

 1.Main Module
       Application object
 2.Sub Modules
       Collection of other objects
////////////////////////////////////////////////////////////////////////////////////////////////////////

Point : any object (module,componetn,service....) is created by angular di subsystem only

if you want to create object. you need template: ts class



class AppComponent {
  constructor() { }
}
//let appCmp = new AppComponent()


import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'ng-app';
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

how plain ts class becomes compoent(controller).


class Person{
   //common data
}

class Employee extends Person {

}

class Component{
   id;
   template
   templateUr
}

class AppComponent extends Component {


}

 new AppComponent();

Instead of writing inheritance model, we use loosly copuled inheritance : decorator.

Every infra object must be decorated

module : @NgModule
compone : @component
service ; @injectable
directive : @directive
pipe : @pipe

@input
@output
@viewC
.......

Decorator meta Object:

 -input of decorators
most of the decorators which takes parameter as object : decorator meta object


Properties of Component decorator meta object:

1.selector
	app-root
  <app-root></app-root>- html element ? like h1,div

HTML 5 concept 
  ->custom elements, dev , can introduce new elements inside html.


 h1 ------>brwser engine-- executes a program behind(c) ---result in browser

 
<app-root></app-root> ---brwser engine-- executes a program|WebcomponentRegistry
					 ->javascript program


Any custom element will have js 

   <app-root> ----Fires/executes-js----ts-Component


////////////////////////////////////////////////////////////////////////////////////////////////////

Application Req:

1.Must have root module : app.module.ts :Application object
2.Must have app component : Landing page of Ng.
////////////////////////////////////////////////////////////////////////////////////////////////////

Component:Controller and data

How to represent data in ng: Data binding


Data binding patterns
......................

1.interpolation

2.Type of binding
property 

Target : on which binding , can be enabled

Element
<img [src]="heroImageUrl">
Component property
<app-hero-detail [hero]="currentHero"></app-hero-detail>
Directive 
<div [ngClass]="{'special': isSpecial}"></div>

3.Type of binding
Event

Target:
Element event
<button (click)="onSave()">Save</button>
Component event
<app-hero-detail (deleteRequest)="deleteHero()"></app-hero-detail>
Directive event
<div (myClick)="clicked=$event" clickable>click me</div>

4.Two-way	
Event and property	

Target
Event and property	
<input [(ngModel)]="name">


5.Attribute	
Attribute (the exception)

Target
<button [attr.aria-label]="help">help</button>


6.Class	
class property

Target
<div [class.special]="isSpecial">Special</div>

7.Style
style property	
<button [style.color]="isSpecial ? 'red' : 'green'">

////////////////////////////////////////////////////////////////////////////////////////////////////

property binding :  []

1.component to component data passing

2.Element property binding : []

  <img [src]="variableName">


<img [src]="itemImageUrl">
<p><img src="{{itemImageUrl}}"> is the <i>interpolated</i> image.</p>

<p><span>"{{interpolationTitle}}" is the <i>interpolated</i> title.</span></p>
<p>"<span [innerHTML]="propertyTitle"></span>" is the <i>property bound</i> title.</p>

<!--Attribute binding-->
<h1>Attribute Property Binding</h1>
<button [disabled]="isEnabled">Save</button>
<h1>Class Binding :via ngClass Directive</h1>
<!--Class Binding via ngClass directive-->
<h1>Class Binding :via by adding class.special Directive</h1>
<p [class.special]="false">binding to the classes property making this blue</p>
<h1>Style Binding</h1>
<!--static styles-->
<div style="color: red">Some text</div>
<!--dynamic style-->
<div [style.color]="somecolor">Some text</div>
<div [style]="mystyle">Some text</div>
<hr>


CSS:

types of css
1.inline style
  <style>
  </style>
2.external style 
 <link> - myapp.css

Angular styles can be added

1.inside project 

src/styles.css :
  ->global styles

third party styles : bootstrap

angular.json
under
"styles": [
              "src/styles.css",
              "node_modoules...."
            ]

2.component specific styles

 Styles applied to that component only or  component and its childerens
  styles: ['h1 { font-weight: normal; }']
  styleUrls: ['app.component.css'],


styles can be added in two wasy

using class,style property

<h1 class="layout color font">
<h1 style="style">

dynamic styles

class :
 <element [class.className]="condition">
 <element [class]="classes">

style
 <element [style.styleName]="condition">
 <element [style]="styleobject">

/////////////////////////////////////////////////////////////////////////////////////////////////////

2.component specific styles

 Styles applied to that component only or  component and its childerens
  styles: ['h1 { font-weight: normal; }']
  styleUrls: ['app.component.css'],


if you apply styles through styles/styleurls, 

  css will be applied only that component : css scope


Use case : only to that component : default 

Where the style tag added?
   -head element
  <head>
    <style>
        
    </style>
encapsulation : ViewEncapsulation.Emulated


Use case : component + its childeren

Style in the global
<head>
    <style>
    </style>

   encapsulation: ViewEncapsulation.None //compoent + parent

Style in the component and its hierachy only:

//////////////////////////////////////////////////////////////////////////////////////////////////

Event binding

    <button (click)="onUpdate('employee')" >Update</button>
  onUpdate(input) {
    alert('On update is called' + input)
  }

two way data binding
 <input type="text" (input) ="onChange($event)">
    <h1>{{userInput}}</h1>

 userInput: string = ";"
  onChange(evt: any) {
    this.userInput = evt.target.value
  }

code refactoring:
................
1 <input [value]="quote" (input)="quote=$event.target.value">

2.event+property  [(ngModel)]

ngModel : it is object, used to transfer data : dto object


Custom Events:
..............
Component - Communcation 
 
1.parent - child : via property

2.child - parent : custom events

3.inter components : services and rxjs

///////////////////////////////////////////////////////////////////////////////////////////////////////

Modularity and DI , Services:
.............................

es 6 modularity
angular modularity
-object module object

module object is container object
  which contains other objects
    -module-submodule
    -components
    -services
    -pipes
    -directies
 etc..........

how to create module object


->Main module
  Every angular application must have main module : app.module.ts 
-sub module

@NgModule


import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }




import { NgModule } from '@angular/core';


@NgModule()
export class AppModule { }


Dependency Injection:
1.object creation
    ->angular creates objects via special service "injectors"
2.mapping object relationship
    ->angular uses concept called "Providers"/declarions/imports
  
  declarations: [],
   contains view Objects 
        - component,dirctive,pipe

  imports: [],
                         
	submodule dependency. -@NgModule

  providers: []

    services ---@injectable


3.Grab object reference
   ->dependency object is grabbed inside an object through constructors

eg;
   Customer ----has a dependency ---- Order


3.Grab object reference
   ->dependency object is grabbed inside an object through constructors

 class Customer{
       constructor(private order:Order){}
  }





Flow of object creation
  
main.ts
 
Application object creation begins

   -platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));
      |
      
       AppModule
	  ->declarations: [AppComponent]
			|
			---------------------->AppComponent Object is created<---App component 										 dependency
	      
	 
        -imports: [
   		 BrowserModule,
 	 ]
			|
			----------------BrowserModule<----depencies<---depdencies

////////////////////////////////////////////////////////////////////////////////////////////////////

Angular app architecture

src/
   app
     - basic files
    -domainfolder
      greeter

Note : any object if create, must be spcified in the angular di configuration.

What if i create new component?


Submodule: creation.


scope:
 ts : private,public,protected, module(export)

 ng : angular module module:
  
        if any object , "which is part of submodule" : the scope is within that module only

   if you access objects across the modules : in ngModule we have config prop :"exports"

/////////////////////////////////////////////////////////////////////////////////////////////////////

Service:

Service object which contains biz logic and data .

as of now , we have stored data inside controler, we have to separate out from the controller.


types of services:

1.domain specific services
   HelloService,EmployeeSerivce,CustomoerService
2.global services
  Logger,Auth

types of services:

1.sync api
2.async api.
-callbacks - old
-promises - old
-Reactive Programming.


Where can i inject services?

-App Module : we can access service across application : single ton.
   -global
 providers
-sub Module : we can access services within that submodule
  -module
 providers
-component  : we can access that service only with in that component
 -
 providers


Code reactoring with respect services:
.......................................

data can be loaded on to ui

1.inital load

	
--->lifecycle hooks: ngOnInit----OnInit

2.through user interactions : events


exports : view objects,submodules
/////////////////////////////////////////////////////////////////////////////////////////////////////

RXJS:
....

Reactive Programming :

it is hybrid programming model ,Which is extending existing pl more powerfull.


1.observer pattern
  event driven programming
  publisher ----subscriber

2.iteratore pattern
   how to get data from the source(data source)
 
 -pull based programming
 -push based programming


3.functional style programming
 
  ->pure functions and immuablity : the function never mutates the state(data), rather it returns
  new /fresh data always


 Reactive = {ob +iter+functional}

How to implement reactive Modles?

  X-Extension on existing languages

 ReactiveX 

The first Reactive Implementation from netflix : rxJava

 JAVA + rEACTOVE ==> JAVA With Reactivex.

after that many pl adopted extions

1.js ====> RX ===rxjs :Reactive Extensions Library for JavaScript


rxjs:

write powerfull reactive programming.
///////////////////////////////////////////////////////////////////////////////////////////////////

Reactive Programming and angular :

Angular integreated rxjs to make  "Reactive Angular Application"


Reactive Ang:

1.HTTP
2.Routers
etc.............

Coding :

Fundamentals rxjs:


1.data source

2.push data into stream

Stream : as object

->Observable : Stream.


3.consumer

import { Observable } from 'rxjs';


const dataSource = 'Hello Reactive!!!!';

//create Basic stream
const stream = new Observable(subscriber => {
    //push data into stream
    subscriber.next(dataSource); //emit data event,then data channel is used to send data
    subscriber.next('Hello Rxjs!')
    // subscriber.error('heay')
    subscriber.complete(); //emit complete event , which will trigger completed
});

//Consumer : open three channel(data,error,complete)

stream.subscribe(data => console.log(data), err => console.log(err), () => console.log('done!'));
///////////////////////////////////////////////////////////////////////////////////////////////////////

                                        DataSource
                                           |
                             Stream <-----Push the data into stream from dataSource
                               |
                            emits event
                   --------------------------------
                   |           |                 |
                 data         err             complete
                  ||          ||                ||
                  ||          ||                ||   --->Channel which is used to transmit data


                           subscriber  ------>Listing for any one of the events


Stream : It is object, In reactive Progamming stream is represented through special type(class/Object)
 Observable

if error is thrown, the stream will be closed.
if stream is  completed, the stream will be closed.


By default streamming is sync.

How to make async streaming?


///////////////////////////////////////////////////////////////////////////////////////////////////

How to create  fresh stream?

1.create stream from scratch
    new Observable()

2.crate stream using operators


operators : methods

1.creational operators
 create stream from data source.

data source could be "single value,sequence of values,array,promise,dom events,generators".

/////////////////////////////////////////////////////////////////////////////////////////////////////

Stream types :

  Up stream

  down Stream

Why reactive programmig?
  -For data processing : streaming way.

eg:

  list of numbers ->array

Use case : i want to find out even numbers from array.

 array.filter(prdicate function==>true /false)===>new filtered Array :functional programming.

In reactive programming ,"Stream" is pure, if u perform any stream processing, always returns new stream


Operators : pure function

in reactive , all operators are pure function, which returns always new Observable, never mutates old state.


Stream Processing:

stream.operator1().operator2().operatorN().subscribe()

rxjs stream processing syntax

upstream.pipe(operator1,operator2,operator3).subscribe

map,filter,tap:
...........




//tap : is used for logging purpose

import { of } from "rxjs";
import { tap, map, filter } from "rxjs/operators";


//chaining pattern
const { log } = console;

//data processing
of(1, 2, 3, 4, 5, 6, 7) //up stream
    .pipe(
        tap(item => log(`Emits for each value ${item}`)),
        map(value => value * 3),  // new stream : down stream | upstream
        filter(newItem => newItem % 2 === 0) // new stream based truthy values
    )
    .subscribe(log, log, () => log('done'))


//////////////////////////////////////////////////////////////////////////////////////////////////////

Broad casting:
.............

Producer(Stream)-----can be connected with ---one Subscriber : one to one
  This communication style is called "unicast".

Producer(Stream)----can be connected with ----->many subscribers : one to Many
  This communication style is called "Multicast".

Based on this communication style stream can be classified into two category.

1.Cold Observable(Cold Stream)
2.Hot Observable(Hot Stream)


1.Cold Observable

1.Observable that doesn’t emit items until a subscriber subscribes.

2.If we have more than one subscriber, then observable will 
emit sequence of items to all subscribers one by one.

3.Each subscriber get fresh copy of the data from the begining.

4.Most of Observerables are Cold.

//////////////////////////////////////////////////////////////////////////////////////////////////

Hot Observable:

1.Observables that don’t wait for any subscription. They start emitting items   when created.
2.They don’t emit the sequence of items again for a new subscriber.
3.When an item is emitted by hot observable, all the subscribers that are   subscribed will get the emitted item at once.


There are many ways to implement hot observables:

1.ConnectableObservable : publish and connect
 publish will start publishing data to multiple subscribers and as soon as connect is called

2.share method
  Can be shared a stream among subscribers  by call

3.Subjects


How to cancel subscription ? if subscribers willing to stop getting data?


subscribe method returns "Subscription object" on which you can cancel


//////////////////////////////////////////////////////////////////////////////////////////////////////

Subjects:

What is a Subject?  :create the hot observable from scratch
  
 In RxJS Subject is a special type of Observable that allows values to be multicasted 
 to many Observers.

While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.

"each subscribed Observer owns an independent execution of the Observable"
   =>Every Subscribers has its own independent copy of the Object.
   lets say 10 subscribers, 10 Observable copy is maintained.

 "A Subject is a special type of Observable which shares a single execution path among observers"

"You can think of this as a single speaker talking at a microphone in a room full of people. Their message (the subject) is being delivered to many (multicast) people (the observers) at once. This is the basis of multicasting. Typical observables would be comparable to a 1 on 1 conversation".


There are 4 variants of subjects:

1.Subject - No initial value or replay behavior.


2.AsyncSubject - Emits latest value to observers upon completion.

3.BehaviorSubject - Requires an initial value and emits its current value (last emitted item) to new subscribers.

4.ReplaySubject - Emits specified number of last emitted values (a replay) to new subscribers.


1.AsyncSubject :
 AsyncSubject will emit only the last value to its subscribers when source observable completes.

 AsyncSubject will get all the items emitted by source observable but only emit the last item when source observable calls its "complete" method


2.BehaviourSubject :
 BehaviourSubject emits the most recently item at the time of subscription or 
 a default item if none has been emitted and then continues the sequence until complete.


  BS == Will have default value, which emitted up on subscrition.


ReplaySubject
    A ReplaySubject is similar to a BehaviorSubject in that it can send old values to new subscribers, but it can also record a part of the Observable execution.


const subject = new ReplaySubject(3); // buffer 3 values for new subscribers


/////////////////////////////////////////////////////////////////////////////////////////////////////

Angular and RXJS:
.................

ng integrated rxjs , simplified lot of things : Rxfixifaction.

rxfied: lot of api in angular uses rxjs libs built in.

HTTPClient:

Service, which is used to connect rest end points from angular.

HTTPClient internally wraps rxjs : Observable.

Router: 

which wraps rxjs libs

Event Emitter 

which wraps rxjs libs

Forms :reactive forms

which wraps rxjs libs


///////////////////////////////////////////////////////////////////////////////////////////////////////



View ------Component--------------Services------http--------BackEnd Rest End Points



import { HttpClientModule } from '@angular/common/http';


appmodule
imports[HttpClientModule]
////////////////////////////////////////////////////////////////////////////////////////////////
Objects(Services) in the HTTPClient Module

HTTPClient
  -for making http calls, get,post,delete,put.  
  all api return type is Observable.

HTTPParams:
 To handle req and response parameters such as query params,path params...,content-type,content-length
header values.


HttpHeaders:

to set new Header Values

HTTP error handling:

catchError(value=> of("error" )


handleError<T> (serviceName = '', operation = 'operation', result = {} as T) {

    return (error: HttpErrorResponse): Observable<T> => {
      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      const message = (error.error instanceof ErrorEvent) ?
        error.error.message :
       `server returned code ${error.status} with body "${error.error}"`;

      // TODO: better job of transforming error for user consumption
      this.messageService.add(`${serviceName}: ${operation} failed: ${message}`);

      // Let the app keep running by returning a safe result.
      return of( result );
};

curry pattern

class ErrorHandler{
  function createHandleError(serviceName){

	function handlerError(serviceName,operation,result){ 

		return function(err){

			return of(errorMessage)
		}
	}
  }

}
/////////////////////////////////////////////////////////////////////////////////////////////////////


i have two compoents ; i want to publish data which is comming from rest end point.


comp-1
         <----------       <--Hot--(cold)Observable---GET----HTTP
comp-2			   (Subject/apis)
 
i have component ; i want to display data based on some conditon: i want to show list of customers
based on city.

comp-1
         <----------       Observable.pipe(filter,map,...)---GET----HTTP
comp-2			   
 
.............................................XXXXXXXXXXXX........................................

obj---data,err,complet

sub-data,err,complete

how to handle error as normal data.


response : data

error--dont exception ===> response (error) {message:'error',code:500}

find():Promise<any> - resolve,rject

resolve(data)

reject('test')

async function fetch(){
 
  try{ 
  const todos= await todoService.find()
  }
  catch(err){
   
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

Forms:
......

Angular Forms:


--->Forms are used to get input and send input to the compoent

Forms are designed using html form elements
 <form>
  <input>
  <select>

how to get input
how to validate
  

Types of forms:

1.Reactive / model driven forms

More robust way of designing forms.

Characterics of reactive/model driven forms

1.scalability
2.resuablity

Reactive forms programmetic way of designing forms.

Template contains basic forms and its controls : design

Component will controll the behaviour of forms  :validation,data reading and writing.

Reactive form means, forms are bound with "Observable".



///////////////////////////////////////////////////////////////////////////////////////////////////

Lets code;

All form features which are reprsented in @angular/forms namespace

->ReactiveFormsModule - reactive/model driven forms features

-FormsModule -template driven forms features

Steps 1: inject ReactiveFormsModule in any submodule / app module


ReactiveFormsModule contains lot of directives

Directives extends the behaviour of  existing dom elements.
 ->Directives are custom attributes of any dom elements.

1.FormGroup
    Object which represents group.
2.FormControl
   Object which represents any form input elements

 <input type="text"   myattr="myvalue"  formControl >
         |             |         
       attribute    custom attribute

3.Form Model:
  Which is object used to transfer data from the form controls to Component and component to formControls.

        Form(View)    -------Model--------------- Component



Step 2 : 

Design basic form template

<div class="container">
  <h1>Reactive Form Application</h1>
  <form novalidate>

    <fieldset>
      <div class="form-group">
        <label>First Name</label>
        <input type="text" class="form-control">
      </div>

      <div class="form-group">
        <label>Last Name</label>
        <input type="text" class="form-control">
      </div>
    </fieldset>

    <div class="form-group">
      <label>Email</label>
      <input type="email" class="form-control">
    </div>
    <div class="form-group">
      <label>Password</label>
      <input type="password" class="form-control">
    </div>
    <div class="form-group">
      <label>Language</label>
      <select class="form-control">
        <option value="">Please select a language</option>
      </select>
    </div>
  </form>
</div>
///////////////////////////////////////////////////////////////////////////////////////////////////////

Data binding with fields:
...........................

 <div class="form-group">
      <label>Language</label>
      <select class="form-control">
        <option value="">Please select a language</option>
        <option *ngFor="let lang of langs" [value]="lang">
          {{lang}}
        </option>
      </select>
    </div>


Step 3:

Binding FromGroup and Form Control instance with Form elemements.

Form control binding

                      directive
		        |
<input type="text"  [formControl]="userNameControl">
                       |                 |
                   FormControl Object   referenceVariable

inside component
                userNameControl = new FormControl()

FormControl objects can be grouped or organized under one unit called "FormGroup"

FormGroup is collection of FormControl Object

<form [formGroup]="myform"> ... </form>
         |
      myForm = new FormGroup(
      {
         userNameControl: new FormControl(),

      }

     )

A single FormGroup can have nested form groups and intern it can have its form controls and form groups
	
   form groups are represented by "<fieldset formGroupName="name">


code :


html template:

<div class="container">
  <h1>Reactive Form Application</h1>
  <form [formGroup]="myform" novalidate>

    <!--Sub Group : nested forms : nested Group-->
    <fieldset formGroupName="name">
      <div class="form-group">
        <label>First Name</label>
        <input  formControlName="firstName" type="text" class="form-control">
      </div>

      <div class="form-group">
        <label>Last Name</label>
        <input formControlName="lastName" type="text" class="form-control">
      </div>
    </fieldset>

    <div class="form-group">
      <label>Email</label>
      <input formControlName="email"  type="email" class="form-control">
    </div>
    <div class="form-group">
      <label>Password</label>
      <input formControlName="password" type="password" class="form-control">
    </div>
    <div class="form-group">
      <label>Language</label>
      <select formControlName="language" class="form-control">
        <option value="">Please select a language</option>
        <option *ngFor="let lang of langs" [value]="lang">
          {{lang}}
        </option>
      </select>
    </div>
  </form>
</div>


Component:


import { Component } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';


@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {


  //Data 
  langs: string[] = [
    'English',
    'French',
    'German',
  ]
  //create FormGroup Object and FormControl Object.
  myform: FormGroup;

  ngOnInit() {
    this.myform = new FormGroup({
      //nested form group
      name: new FormGroup({
        firstName: new FormControl(),
        lastName: new FormControl(),
      }),
      email: new FormControl(),
      password: new FormControl(),
      language: new FormControl()
    });
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

How to read forms values?

  <form [formGroup]="myform" novalidate>

  </form>

code:

 myform.value

  <pre>{{myform.value | json }}</pre>
///////////////////////////////////////////////////////////////////////////////////////////////////////

Step 4: Default values and Validation
......................................

default values:

  new FormControl()

  this.myform = new FormGroup({
      //nested form group
      name: new FormGroup({
        firstName: new FormControl('Subramanian'),
        lastName: new FormControl('Murugan'),
      }),
      email: new FormControl(''),
      password: new FormControl(''),
      language: new FormControl(this.langs[0])
    });

Validation:
 validation is done at component level.

Validation is done through a validation framework in angular.

 name: new FormGroup({
        firstName: new FormControl('Subramanian', Validators.required),
        lastName: new FormControl('Murugan',Validators.required),
      })

Add more validation rules for a particular control.

 array of validators

 ctrlName:new FormControl('',[])

import { Component } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';


@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {


  //Data 
  langs: string[] = [
    'English',
    'French',
    'German',
  ]
  //create FormGroup Object and FormControl Object.
  myform: FormGroup;

  ngOnInit() {
    this.myform = new FormGroup({
      //nested form group
      name: new FormGroup({
        firstName: new FormControl('Subramanian', Validators.required),
        lastName: new FormControl('Murugan', Validators.required),
      }),
      email: new FormControl('',
        [
          Validators.required,
          Validators.pattern("[^ @]*@[^ @]*")]
      ),
      password: new FormControl('', [
        Validators.required,
        Validators.minLength(8)]),
      language: new FormControl(this.langs[0])
    });
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////

Form Control States : 

1.dirty
2.pristine
3.touched
4.untouched
5.valid
6.invalid

how to get theses values in template

We can get a reference to these form control instances in our template through the controls property of our myform model,
for example we can print out the the dirty state of the email field like so:

<input formControlName="email" type="email" class="form-control">
<pre>Dirty? {{ myform.controls.email.dirty }}</pre>

 <p>Email States</p>
      <pre>Dirty? {{ myform.controls.email.dirty }}</pre>
      <pre>Pristine? {{ myform.controls.email.pristine }}</pre>
      <pre>Touched? {{ myform.controls.email.touched }}</pre>
      <pre>UnTouched? {{ myform.controls.email.untouched }}</pre>
      <pre>Valid? {{ myform.controls.email.valid }}</pre>



Validation Styling:

Bootstrap has classes for showing visual feedback for form controls when they are invalid.

For instance if we add the has-danger class to the parent div of the input control with the class of form-group it adds a red border.

   <div class="form-control-feedback"
        *ngIf="myform.controls.password.errors && (myform.controls.password.dirty || myform.controls.password.touched)">
        <p *ngIf="myform.controls.password.errors.required">Password is required</p>
        <p *ngIf="myform.controls.password.errors.minlength">Password must be 8 characters long, we need another
          {{myform.controls.password.errors.minlength.requiredLength - myform.controls.password.errors.minlength.actualLength}}
          characters </p>
      </div>

*ngIf="myform.controls.password.errors && (myform.controls.password.dirty || myform.controls.password.touched)"

Submitting & Resetting
.......................

<form>
  .
  .
  .
  <button type="submit" class="btn btn-primary" >Submit</button>
</form>

<form (ngSubmit)="onSubmit()">
  .
  .
  .
  <button type="submit" class="btn btn-primary" >Submit</button>
</form>

onSubmit() {
  if (this.myform.valid) {
    console.log("Form Submitted!");
  }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////

import { Component } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';


@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {


  //Data 
  langs: string[] = [
    'English',
    'French',
    'German',
  ]
  //create FormGroup Object and FormControl Object.
  myform: FormGroup;

  ngOnInit() {
    this.myform = new FormGroup({
      //nested form group
      name: new FormGroup({
        firstName: new FormControl('Subramanian', Validators.required),
        lastName: new FormControl('Murugan', Validators.required),
      }),
      email: new FormControl('',
        [
          Validators.required,
          Validators.pattern("[^ @]*@[^ @]*")]
      ),
      password: new FormControl('', [
        Validators.required,
        Validators.minLength(8)]),
      language: new FormControl(this.langs[0])
    });
  }

  onSubmit(){
    if (this.myform.valid) {
      alert("Form Submitted!");
      console.log(this.myform.value)
      this.myform.reset();
    }
  }

}
////////////////////////////////////////////////////////////////////////////////////////////////////

How to use Observable in forms : Reactive Forms


import { Component } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';
import { debounceTime, distinctUntilChanged, filter } from 'rxjs/operators';


@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {


  //Data 
  langs: string[] = [
    'English',
    'French',
    'German',
  ]
  searchField: FormControl;
  searches: string[] = [];


  //create FormGroup Object and FormControl Object.
  myform: FormGroup;

  ngOnInit() {
    this.myform = new FormGroup({
      //nested form group
      name: new FormGroup({
        firstName: new FormControl('Subramanian', Validators.required),
        lastName: new FormControl('Murugan', Validators.required),
      }),
      email: new FormControl('',
        [
          Validators.required,
          Validators.pattern("[^ @]*@[^ @]*")]
      ),
      password: new FormControl('', [
        Validators.required,
        Validators.minLength(8)]),
      language: new FormControl(this.langs[0])
    });
    //search Field Object
    this.searchField = new FormControl('');

    //Search Logic : get search items and add into an array
    this.searchField.valueChanges
      .pipe(
        debounceTime(1000),
        distinctUntilChanged(),
        filter(v => v !== '')
      ).subscribe(item => {
        this.searches.push(item);
      })


  }

  onSubmit() {
    if (this.myform.valid) {
      alert("Form Submitted!");
      console.log(this.myform.value)
      this.myform.reset();
    }
  }


}

    <div class="form-group">
      <input type="search" class="form-control" placeholder="Please enter search term" [formControl]="searchField">

      <ul>
        <li *ngFor="let search of searches">{{ search }}</li>
      </ul>

    </div>

point:

 please have a look at the
control.statusChanges -----Validation and Observables

********************************&&&&&&&&&&&&&&&&&&&&&&&&&&&&&******************************************

Template Driven forms:

Form data binding
Form validation
Most of the form operations are done in the template where reative/model driven forms most of the things
are done at component.


Template driven forms which is from 'FormsModule'


Templates driven forms uses model object to transfer data between view and component

View<--->ngModel-uses-DomainModel<----->Component


Steps:

Step 1:

FOrmsModule injection

import {FormsModule } from '@angular/forms'

 imports: [
     FormsModule,
 ]

Step 2:

create Domain model object


export class PostFormModel {
    constructor(public id: number, public title: string, public author: string) { }
}

create Object for those domain models

export class AppComponent {
  post: any;
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko')
  }
}


Step 3 : 

Create inital form Template
<div class="container">
  <h1>Post Form</h1>
  <form>
    <div class="form-group">
      <label for="title">Title</label>
      <input type="text" class="form-control" id="title" required>
    </div>

    <div class="form-group">
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name" required>
    </div>

    <button type="submit" class="btn btn-success">Submit</button>

  </form>
</div>

Step 4:

Data binding
   Binding textbox(form controls) with Model Object
   We have many ways
  1.through instance variable,$event
  2.through [(ngModel)]="post.title"
   ngModel = > it is an object from "FormsModule"
   ngModel it is dto object=>data transfering between view and component.

Template  Reference Variable for form tag
 
How to access dom elements?
eg;
<input>

inside component
  $event passed as parameter to event listener

inside template
 from one elment to another element
 $event

eg:
<input (input)="myvar=$event.target.value">

<h1>{{myvar}}</h1>

#templateRef : 

 <input #mybox>

 <h1>{{mybox.value}}</h1>

<form  #postForm> - the whole form object will be assigned to 'postformvariable'

<form  #postForm="ngForm">

NgForm
.........
<form #postForm> =>postForm points HTML Form Object

ngForm is Object which inherits HTML Form

class ngForm extends HTMLForm{
  +extra behavior=>Ready made validation code
  +form submission behviours
}

<form #postForm="ngForm">

The variable postForm is now a reference to the NgForm 
directive that governs the form as a whole.

The NgForm directive:

What NgForm directive? You didn't add an NgForm directive.

Angular did. Angular automatically creates and attaches
 an NgForm directive to the <form> tag.

"The NgForm directive supplements the form element with additional features. 


It holds the controls you created for the elements  with an "ngModel directive" and name attribute,
 and monitors their properties, including their validity.
 
It also has its own valid property which is true only if every contained control is valid."

Note: NgForm is built Object ,has more logic for simlifying our form handling process.

//////////////////////////////////////////////////////////////////////////////////////////////////////

ngModel:

Track control state and validity with ngModel:
.............................................

ngModel:
> Using ngModel in a form gives you more than just two-way data binding. 

>It also tells you if the user touched the control, if the value changed, or if the value became invalid.

State 	                        Class if true 	Class if false
The control has been visited.  	  ng-touched 	ng-untouched
The control's value has changed.  ng-dirty 	    ng-pristine
The control's value is valid. 	  ng-valid 	    ng-invalid

State Tracking Steps:

1.Look but don't touch.
2.Click inside the name box, then click outside it.
3.Add slashes to the end of the name.
4.Erase the name.

ng-untouched - if you dont touch
ng-touched - if you touch
ng-dirty - if you changed
ng-invalid - if you remove all-empty field.


Add custom CSS for visual feedback:

Valid + Required - green Color
Valid + optional - white color
Invalid (required | optional) - red Color

Angular Css:
.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}


7.Add name attribute for each form control

  <input name="title">


8.8.Validation Block

 <input [(ngModel)]="post.author" name="author" type="text" #errMsg1="ngModel" class="form-control" id="author" required>


    <div [hidden]="errMsg1.valid || errMsg1.pristine" class="alert alert-danger">
          Author is required
    </div>

   
9.9.Submitting a form
  We need to add ngSubmit event on form element

  <form (ngSubmit)="onSubmit()">




import { Component } from '@angular/core';
import { PostFormModel } from './forms/PostModel';
import { PostService } from './post.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  post: any;
  submitted: boolean = false;

  constructor(private service: PostService) {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko')
  }


  onSubmit() {
    this.submitted = true;
    this.service.save(this.post);
  }

}


//////////////////////////////////////////////////////////////////////////////////////////////////////


<div [hidden]="submitted">
  <div class="container">
    <h1>Post Form</h1>
    <form (ngSubmit)="onSubmit()" #postForm="ngForm">
      <div class="form-group">
        <label for="title">Title</label>
        <input [(ngModel)]="post.title" name="title" type="text" #errMsg="ngModel" class="form-control" id="title"
          required>
        <div [hidden]="errMsg.valid || errMsg.pristine" class="alert alert-danger">
          Title is required
        </div>
      </div>

      <div class="form-group">
        <label for="author">Author</label>
        <input [(ngModel)]="post.author" name="author" type="text" #errMsg1="ngModel" class="form-control" id="author"
          required>
        <div [hidden]="errMsg1.valid || errMsg1.pristine" class="alert alert-danger">
          Author is required
        </div>
      </div>

      <div class="form-group">
        <label for="category">Category</label>
        <select class="form-control" id="category" name="category" 
        required [(ngModel)]="post.category">
          <option *ngFor="let cat of categories" [value]="cat">
            {{cat}}
          </option>
        </select>
      </div>

      <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>

    </form>
  </div>
</div>

<div class="container" [hidden]="!submitted">
  <h2>You submitted the following:</h2>
  <div class="row">
    <div class="col-xs-3">Id : </div>
    <div class="col-xs-9  pull-left">{{ post.id }}</div>
  </div>
  <div class="row">
    <div class="col-xs-3">Title : </div>
    <div class="col-xs-9  pull-left">{{ post.title }}</div>
  </div>
  <div class="row">
    <div class="col-xs-3">Author : </div>
    <div class="col-xs-9 pull-left">{{ post.author }}</div>
  </div>
  <br>
  <button class="btn btn-primary" (click)="submitted=false">GoBack</button>
</div>
/////////////////////////////////////////////////////////

    <input>  ------------ new FormControl
 
    <form group>
        <input formctlnme=xx>            new FormGroup({
				          xx:new FormControl
			                })